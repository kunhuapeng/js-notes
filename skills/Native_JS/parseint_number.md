# 为什么 parseInt (0.0000005) === 5 ?

> 最近在开发中遇到了一个奇怪的问题：`parseInt(0.0000005)===5`😨 按照我们正常的认知，应该输出`0`才是正确的，但是为什么是`5`?

## parseInt

`parseInt(string, radix)`解析一个`字符串`并返回指定`基数`的十进制整数， `radix`是 2-36 之间的整数，表示被解析`字符串`的`基数`。

**语法**

```js
parseInt(string, radix);
```

**参数**

- `string`: 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 `ToString` 抽象操作)
- `radix`：可选参数，从 2 到 36，表示字符串的基数。例如指定 16 表示被解析值是十六进制数。

## 验证传入字符串 '0.0000005'

`parseInt(0.0000005)===5`？根据官方解释，`parseInt` 第一个参数需要是字符串形式的，显然我们传入的是一个浮点数，那么如果我们传入一个字符串的`'0.0000005'`会怎么样？？？

```js
parseInt('0.5');      // => 0
parseInt('0.05');     // => 0
parseInt('0.005');    // => 0
parseInt('0.0005');   // => 0
parseInt('0.00005');  // => 0
parseInt('0.000005'); // => 0
```

> 如果参数不是一个字符串，则将其转换为字符串(使用 `ToString` 抽象操作)

> 意思就是说：`parseInt会将参数自动转换成字符串，再去做取整操作`

## 浮点数手动转换为字符串

```js
String(0.5);      // => '0.5'
String(0.05);     // => '0.05'
String(0.005);    // => '0.05'
String(0.0005);   // => '0.005'
String(0.00005);  // => '0.00005'
String(0.000005); // => '0.000005'

String(0.0000005); // => '5e-7'
```

> 显式转换为字符串的`String(0.0000005)`行为与其他浮点数不同：它是`指数表示法`的字符串表示形式！

```js
parseInt(0.0000005); // => 5
// 类似于
parseInt(5e-7);      // => 5
// 类似于
parseInt('5e-7');    // => 5
```

> **结论：**`parseInt()`总是将其第一个参数转换为字符串，所以小于`10 -6`的浮点数将以`指数表示法`编写。然后 parseInt()`从float的指数表示法中提取整数`！

## 如何安全获取浮点数整数部分

为了安全地提取浮点数的整数部分，建议使用以下`Math.floor()`函数：

```js
Math.floor(0.5);      // => 0
Math.floor(0.05);     // => 0
Math.floor(0.005);    // => 0
Math.floor(0.0005);   // => 0
Math.floor(0.00005);  // => 0
Math.floor(0.000005); // => 0

Math.floor(0.0000005); // => 0
```

